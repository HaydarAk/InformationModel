<h2 id="desc" class="list">Industrial Data Space Information Model: Description <span class="backlink"> back to <a href="#toc">ToC</a></span></h2><h3>3.1 Representation</h3>
<p>The Information Model has been specified at three levels of formalization. Each level corresponds to a digital representation, ranging from a high-level, conceptual document up to the level of operational code, as depicted in Figure 3.13. </p>
<p>The Declarative Representation (IDS Vocabulary) is the only normative specification of the Information Model. A set of auxiliary resources, among others, guidance documents, reference examples, validation, and editing tools is intended to support a competent, appropriate, and consistent usage of the IDS Vocabulary.</p>

<h5><u>Conceptual Representation</u></h5>
<p>The Conceptual Representation of the Information Model (CRIM) provides an analysis and a high-level overview of the main, largely invariant concepts of the Information Model, with no commitment to a particular technology or domain. It mainly targets the general public as well as management boards of organizations by means of a textual document and an understandable visual notation. The descriptions at this level are generic, providing basic information, allowing comparative analysis, and promoting a shared understanding of the concepts. References to the Declarative Representation and the Programmatic Representation are provided, encouraging the reader to take a look into these representations as well in order to learn more details.</p>

<h5><u>Visual Notation</u></h5>
<p>Alongside with figurative, explanatory images, a simplified version of UML class diagrams is used throughout the document, as described in Table 2.</p>

<table>
    <tr>
        <td>
            <b>Element</b></td>
        <td>
            <b>Description</b></td>
    </tr>
    <tr>
        <td>
            <a href="#">
                <img alt="" width=3D"360" height=3D"360" src=""></a></td>
        <td><b>Class diagram</b>
            <div>Class diagrams represent in the context of this
                document concepts with no immediate correspondence to data types defined by the concrete representations of the Information Model. Class attributes
                are designed as external, associated entities for readability purposes.</div>
        </td>
    </tr>
    <tr>
        <td>
            <a href="#"><img alt="" width=3D"360" height=3D"360" src=""></a></td>
        <td><b>Association</b>
            <div></div>
            <div>Association lines represent relationships among concepts. Optional arrow heads indicate the orientation (navigability) of the relation, when appropriate. Optionally, the role and cardinality (multiplicity)
                of the involved concepts is depicted at the respective end. In the given example, the <i>Data Consumer</i> class represents a data sink of a <i>Data Provider</i>, while there is at least one instance of each concept present</div>
        </td>
    </tr>
    <tr>
        <td><a href="#"><img alt="" width=3D"360" height=3D"360" src=""></a></td>
        <td><b>Association class</b>
            <div>
                Association class is a standard UML class with the particular purpose of providing additional information about a relationship between two classes. The association class in the given example describes the nature of the <i>Role</i> a <i>Person</i> plays within
                an <i>Organization</i>.</div>
        </td>
    </tr>
    <tr>
        <td><a href="#"><img alt="" width=3D"360" height=3D"360" src=""></a><a href="#"><img alt="" width=3D"360" height=3D"360" src=""></a></td>
        <td><b>Aggregation and Composition</b>
            <div>Aggregation indicates a containment relation among a part (arrow end) and the whole (unfilled diamond end). The parts exist independently of an aggregate. The composition is a stronger type of
                association. The composite governs the life-cycle of its components, which may not exist independently of the whole (filled diamond end). Paraphrasing the shown example, an <i>Interface</i> contains <i>Operations</i> and both may exist (as concepts) independently.
                On the contrary, <i>Parameters</i> make only sense as part of an <i>Operation</i>.</div>
        </td>
    </tr>
    <tr>
        <td><a href="#"><img alt="" width=3D"360" height=3D"360" src=""></a></td>
        <td><b>Generalization</b>
            <div></div>
            <div>Relationship indicating inheritance, i.e., the hierarchy of concepts. The closed head arrow points from the sub-class to its super-class (generalization).</div>
        </td>
    </tr>
</table>

<h5><u>Declarative Representation</u></h5>
<p>The Declarative Representation of the Information Model (DRIM) defines the normative Information Model of the Industrial Data Space.
    It has been developed along the analysis, findings and requirements of the Conceptual Representation. Based on a stack of W3C technology
    standards (RDF, RDFS, OWL, etc.) and standard modeling vocabularies (DCAT, ODRL, etc.), it provides a formal, machine-interpretable specification
    of concepts envisaged by the Conceptual Representation. Furthermore, it details out and formally defines entities of the Industrial Data Space in
    order to be able to share, search for, and reason upon their structured meta-data descriptions. As such, it comprises a complete referential model
    allowing to derive a number of Programmatic Representations. The ontology is typically used and instantiated by Knowledge Engineers, and Ontology
    Experts. The Declarative Representation defines a reusable, domain-agnostic "core model". It relies on third party standard and custom vocabularies
    in order to express domain-specific facts. According to the common practice, existing domain vocabularies and standards are reused where possible
    fostering acceptance, and interoperability.</p>

<h5><u>Programmatic Representation</u></h5>
<p>The Programmatic Representation of the Information Model (PRIM) targets Software Providers (developers) by supporting a seamless integration of the Information Model with a development infrastructure they are familiar with. This representation comprises a programming language data model (e.g., Java, Python, C++ classes) shipped as a set of documented software libraries (e.g., JAR files). The Programmatic Representation provides best-effort mapping of the Declarative Model onto native structures of a target programming language. This approach supports type-safe development, well-established unit testing, and quality assurance processes. It allows developers to easily create instances of the Information Model that are compliant with the Declarative Representation, relieving them from intricacies of the RDF graph model and ontology processing.</p>


<h3>3.2 Facets</h3>
<p>Each of the three representations outlined above expresses the complete Information Model in a particular way. For the purpose of this document, the overall view was divided into logical groups of concepts (hereinafter called facets), addressing different static and dynamic aspects of the Industrial Data Space. Most of the facets were named after the key concept they contain. Unqualified citations refer to the concept, unless explicitly addressing the facet. Facets do not necessarily correspond to a physical organization of the model (e.g., modules or namespaces), but rather identify the core assets and the different modeling concerns:</p>
<ul>
    <li><b>Resource:</b> Concepts related to the description, provision, commoditization, and usage of resources, i.e., Data Assets and Data Apps, exchanged as digital commodities by participants of the Industrial Data Space.</li>
    <li><b>Data:</b> Concepts particular to Data Assets, beyond the scope of general resources</li>
    <li><b>Application:</b> Concepts particular to Data Apps, beyond the scope of general resources, that are installed within the infrastructure in order to communicate or process data on behalf of participants of the Industrial Data Space.</li>
</ul>
The following Information Model facets deal with the description of entities constituting the Industrial Data Space:
<ul>
    <li><b>Infrastructure:</b> Concepts related to description and verification of certified components used by participants in the Industrial Data Space in order to perform business interactions, or be managed as part of maintenance processes.</li>
    <li><b>Participant:</b> Concepts related to the description, and verification of legal or natural persons that interact using the infrastructure of the Industrial Data Space, assuming certain roles and adhering to formal regulations.</li>
    <li><b>Regulation:</b> Concepts related to the description, formal definition, and enforcement of contracts and usage policies governing the interactions of participants and their use of resources.</li>
</ul>
The remaining facets deal with the description of dynamic scenarios, i.e. the value generating interactions and the maintenance of internal resources and the IDS infrastructure:
<ul>
    <li><b>Interaction:</b> Concepts related to description, instantiation, and evolution of business interactions between participants of the Industrial Data Space, leading to the exchange and consumption of resources in compliance with defined regulations.</li>
    <li><b>Maintenance:</b> Concepts related to the description, execution, monitoring, and clearing of the operational processes within the infrastructure of the Industrial Data Space and the life-cycle management of resources.</li>
</ul>
<p>
    Figure 3.14 illustrates the facets, depicted as high-level concepts, involved in various relationships. Being a mere abstraction, the resource facet was omitted from the figure.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.14: Facets of the Information Model</i>
</p>

<p>
    A set of illustrative examples will be introduced per facet in order to motivate and demonstrate its application. These examples are reused as a reference across the representations of the Information Model and expressed as ontology instances (DRIM) or Java objects (PRIM).
</p>

<h4>Facet 1: Resource</h4>
<p>The resource concept is the root of a simple taxonomy of Industrial Data Space assets, comprising the Data Asset and Data App concepts (see Figure 3.15). A resource, as defined here, is an identifiable, valuable, digital (non-physical) commodity traded and exchanged among participants by means of the infrastructure of the Industrial Data Space. Examples of Data Assets are, among others, textual documents, time series of sensor values, communication messages, archives of image files, or media streams. Data Assets are subject to forwarding, processing, or consumption, with a particular demand for the modeling of related aspects (i.e., context and provenance, structure and usage control). On the contrary, the usage of Data Apps is rather straightforward and largely determined by their functionality. The Data App concept therefore emphasizes a formal description of the function, deployment prerequisites, and maintenance life-cycle (updates).</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.15: Taxonomy of the resource concept</i>
</p>

<p>Despite these differences, both resource types, the Data Asset and Data App, may uniformly be modeled in their capacity as a shared, digital commodity. As depicted in Figure 3.16, a stratified approach was chosen in order to disaggregate the spectrum of concerns related to their interchange. It resulted in the definition of dedicated views looking at the Content, Communication, and Commodization of resources (here termed as "3C Principle").</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.16: Views of the resource (3C principle)</i>
</p>

<p>The Content View describes the inherent substance of a resource. The Communication View defines the means to communicate that content in terms of service operations. Legal, contractual, and commercial aspects complementing the resource concept are described by the Commodization View. Each view introduces a particular, new perspective on the resource. In order to cope with its complexity, a view may be refined into complementary layers, each one providing level of detail that build upon another, as illustrated in Figure 3.17.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.17: Relation of Views and Layers</i>
</p>


<h5><u>Content View</u></h5>
<p>The Content View considers the resource per se, regardless of its distribution, at three distinct Layers. The kind layer addresses the abstract content structure, e.g. "image", "table", "data record", "application", or collection of above, independently of a physical representation. The Representation Layer concretizes a related content kind by introducing further dimensions and constraints unique to its particular serialization, e.g. JPEG image, Excel sheet, SenML XML document or Debian software package. Both layers represent prototypical "blueprints" of content, i.e., a set of virtual instances that may comply with those models. The Artifact layer concentrates on individuals (deliverable artifacts), and such it allows to express aspects that are specific to a concrete resource instance, e.g., a particular document, image or application build.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.18: Layers of the Content view</i>
</p>

<h5><u>Kind Layer</u></h5>
<p>For modeling purposes, different, generic Kinds of Content are assumed. Named kind of content has a permanent identifier that is unique within a context or collection. There is no identifier (name) for anonymous content. Both kinds of content are disjoint, i.e., there is no single entity that is simultaneously an instance of both concepts.</p>
<p>Raw Data is an opaque sequence of bytes which is either bounded (e.g., a binary file) or unbounded (e.g., a media stream). No assumptions are made about its internal nature. Data Point consists of a single, primitive value which is an instance of a simple, basic data type. Record corresponds to a complex data type composed of nested structures and terminal primitives.</p>
<p>Collections are a utility kind of content used to internally organize and enable access to groups of the aforementioned content kinds without interfering with the definition of the included elements. Lists are collections ordered according to a sort criterion allowing for a position/index-based access to elements, their sorting and grouping. Lists of resources may be ordered according to one or more dimensions. Data Points are usually ordered by time(stamps) or the element values. Records further allow for ordering by the attributes of embedded structures. Standalone elements (files) allow for ordering by file properties. Maps are collections that support a random, key-based access relying on a persistent identifier given to a resource. Whereas the concepts of Raw Data, Data Point and Data Record distinguish different levels of structuring – which often coincide with various stages of processing that data has undergone – collections are generic containers for bundling those kinds of content. Standardized serializations of the collection concept should be defined to comply with the respective representation of content.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.19: Partial taxonomy of content kinds</i>
</p>
<p>The content kind of a resource and the type of collection determine the strategies to address the resource, or to select a range of (one or more) elements out of the collection. Table 3 summarizes some envisaged reference strategies.</p>
<br>
<p>
    Table 3: Summary of referencing strategies
</p>

<table>
    <tr>
        <td><b>Referencing strategy</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Reference by ID</td>
        <td>A standalone resource, or an element of a Map, is referred to by its unique name
            (identifier)</td>
    </tr>
    <tr>
        <td>Reference by index</td>
        <td>An element of a List is referred to by its absolute numeric position (index)</td>
    </tr>
    <tr>
        <td>Selection by volume</td>
        <td>A range of an ordered data continuum (List or stream of Raw Data) is selected by data volume (e.g., every 5 MB)</td>
    </tr>
    <tr>
        <td>Selection by time</td>
        <td>A range of a time-ordered data continuum is selected by a time instant (index) or time range</td>
    </tr>
    <tr>
        <td>Selection by count</td>
        <td>A range of ordered data items is selected by counting (e.g., every 10,000 items)
        </td>
    </tr>
</table>

<p>The following table summarizes the relation of the Content Kind, Collection type, referencing strategies, and operations available.</p>

<p>Table 4: Summary of referencing strategies per content kind</p>

<table>
    <tr>
        <td><b>Content Kind</b></td>
        <td><b>Properties</b></td>
    </tr>
    <tr>
        <td>Raw data</td>
        <td>Opaque sequence of bytes (e.g. binary file or media stream)<br>

            &#8226; Access by ID, if named<br>

            &#8226; Access by time (range, instant) or volume, if unbounded<br>

            &#8226; Operations: No filtering, no grouping, no sorting</td>
    </tr>
    <tr>
        <td>Value collection</td>
        <td>Collection of transient, anonymous Data Points or Records (e.g. sensor readings)<br>

            &#8226; Access by index, volume and count, if ordered<br>

            &#8226; Access by time, if time-ordered (time series)<br>

            &#8226; Operations:<br>

            &#8226; Listing (values)<br>

            &#8226; Pagination, if ordered<br>

            &#8226; Filtering, grouping, sorting, if ordered and structured</td>
    </tr>
    <tr>
        <td>Resource collection</td>
        <td>Collection of persistent resources, e.g. files
            <br>

            &#8226; Access by ID<br>

            &#8226; Access by index, volume, and count, if ordered<br>

            &#8226; Access by time, if time-ordered<br>

            &#8226; Operations: <br>

            &#8226; Listing (IDs, values)<br>

            &#8226; Pagination, if ordered<br>

            &#8226; Filtering, grouping, sorting, if ordered and structured an or on file-property level</td>
    </tr>
</table>

<h5><u>Representation Layer</u></h5>
<p>The Representation Layer defines serializations, i.e. physical representations of a related Content Kind. For example, the "image" Kind of Content might be provided as a raster (JPEG, PNG, GIF) or a vector graphics Representation (SVG). Developers of an "application for image anonymization" might provide alternative software Representations (Windows EXE, Debian DEB, or Java JAR) supporting different software environments and operating systems.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.20: Outline of the Representation concept</i>
</p>

<p>A Representation of a content Kind is defined, among others, by a Data Type specified in terms of a Schema (i.e., formal description of the structure of data), and a Media Type, optionally augmented by Profiles (i.e., additional informal specifications and constraints that may apply). A Reference to a standard specifying that type of information should be provided, when existent. The Representation might specify a Mapping to an equivalent, but syntactically incompatible serialization. The Representation may further indicate available Packaging options to combine contents into a single Archive (tar), apply Compression (gzip) and Encryption algorithms (AES).</p>

<h5><u>Artifact Layer</u></h5>
<p>The Artifact layer focuses on the description of deliverable resource instances. Going beyond the prototypical Kind and representation models, it captures properties that are unique to individual materializations of the resource. Such, for example, a particular assembly of data might be individually referenced and associated with a custom Commodization model. The Artifact view of an application build would, for example, define its inherent characteristics, the distribution size, configuration options or software dependencies etc.</p>
<p>The previous sections introduced the Content Layers of a resource. Aspects that apply to a description of Content in general are presented in the following. They will be augmented later on by aspects of Data Asset and Data App that apply only to the respective subclass of the resource concept.</p>

<h5><u>Provenance</u></h5>
<p>Provenance is concerned with the origin of the Content, as well as with the traceability of the processing steps the Content has undergone, and finally, also with the Agents that are responsible for those Activities. The main goal of provenance tracking is to ensure the reliability of the Content, so that modifications are made explicit, comprehensible and may be analyzed for defects.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.21: Outline of the Provenance concept</i>
</p>

<h5><u>Communication View</u></h5>
<p>The Communication View deals with the (dynamic) communication of resource content. Similarly to the Content View, it is defined at multiple levels of detail. The Interface Layer conceptualizes the interchange of digital artifacts as a set of uniform operations (interactions primitives). The Service Layer defines bindings of such generic operations to concrete communication protocols turning them into operable resource endpoints.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.22: Layers of the Communication view</i>
</p>

<h5><u>Interface Layer</u></h5>
<p>Following the Service-oriented Architecture paradigm (SOA) this Layer defines the Interface concept comprising a set of Operations. There are multiple reasons motivating the definition of such an abstract service contract:</p>
<ul>
    <li>Separating a service interface from its implementation is a common practice and mandated by standards like [WSDL2].</li>
    <li>A high-level description of a service interface (with a focus on functionality) allows Data Consumers to easily identify and interpret the interaction logic (i.e., operational capabilities).</li>
    <li>Protocol-specific interface definition languages may either not exist (e.g., [MQTT]), or require reverse engineering in order to infer such information (e.g., [Open API]).</li>
    <li>Conventions and best practices in resource interchange have been informally established within several technological communities (e.g., REST-architecture paradigm). The concept of an abstract, technology-agnostic interaction interface may help to formalize those implicit patterns and foster their re-usability beyond the scope of protocols originally designed for this task (HTTP).</li>
</ul>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.23: Outline of the Interface concept</i>
</p>

<p>Inspired by the REST-architecture paradigm the set of operations available in resource interactions has been restricted to a selection of generic, reusable interaction primitives. The expressiveness of the resultant Resource Interaction Interfaces (RII) has been purposefully limited in favor of designing simple, uniform interfaces that could be easily interpreted by generic, automated clients.</p>

<h5><u>Operations</u></h5>
<p>Operations are the building blocks of an Interface. The operation signature lays down the expected input, its content promise (output parameters) and functional errors that might occur during the invocation (fault parameters).</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3 20: Outline of the Operation concept</i>
</p>

<p>Depending on operations, the interface may support various ways of data provision (Data Source), data reception (Data Sink), and meta-queries allowing the Data Consumer to introspect the interface as depicted by Table 5. Some descriptions refer to Parameter types subsequently defined in the Table 6.</p>
<p>Table 5: Operation types of the Resource Interaction Interface</p>

<table>
    <tr>
        <td><b>Operation type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Query parameter range</td>
        <td>Meta-query operation used by a (potential) Data Consumer to retrieve (a dynamically generated) enumeration of input parameter values (input options); suitable for use cases in which the complete
            parameter range cannot be specified beforehand.</td>
    </tr>
    <tr>
        <td>List identifiers</td>
        <td>Extension of &#8220;Query parameter range&#8221; operation; to be used by a (potential) Data Consumer to retrieve an enumeration of available values for an input parameter of the &#8221;Identifier&#8221; type; to be applied
            to collections of data elements; depending on the type of collection, the identifier may be a unique name (map) or a numeric index (list); the Data Consumer may use the identifiers for a subsequent call to &#8220;Provide data &#8221; operation.</td>
    </tr>
    <tr>
        <td>Provide data</td>
        <td>Operation for providing data via the operation&#8217;s output parameter(s) from the Data Provider to the Data Consumer; (optional) input parameters do not convey significant content and merely configure
            the operation&#8217;s invocation; the description focuses on the Data Provider&#8217;s interface: depending on its implementation, the data is either provided for retrieval upon the Data Consumer&#8217;s request (PULL) or on a subscription basis (PUSH).</td>
    </tr>
    <tr>
        <td>List data</td>
        <td>Extension of &#8220;Provide data&#8221; operation; it is used by a Data Consumer to retrieve an enumeration of values for an input parameter of type &quot;resource&quot;. Optional parameters of type &quot;Order&quot;,
            <br>

            &quot;Sort Key&quot;, &quot;Offset&quot; and &quot;Limit&quot; may be used to create and navigate page-like groupings of data (pagination).</td>
    </tr>
    <tr>
        <td>Filter data</td>
        <td>Extension of &#8220;List data&#8221; operation; requires a mandatory input parameter of the &#8220;Filter&#8221; type (for example, an [LDAP] filter); the filter is used to provide the Data Consumer with a filtered, custom
            subset of the original data elements compliant with the operation&#8217;s output definition; operation is to be applied to &#8220;structured&#8221; data elements or file properties of binary data elements (such as file extension, file name, file type, etc.).</td>
    </tr>
    <tr>
        <td>Select data</td>
        <td>Extension of &#8220;Filter data&#8221; operation; requires a mandatory input parameter of the &#8220;Selector&#8221; type (for example, a [SPARQL CONSTRUCT] query or a partial data template); the selector is used to provide
            the Data Consumer with a selective, custom view of the original data elements compliant with the expression&#8217;s statement; operation is to be applied to &#8220;structured&#8221; data elements only.</td>
    </tr>
    <tr>
        <td>Consume data</td>
        <td>Operation for receiving data via the operation&#8217;s input parameter(s) from the Data Provider to the Data Consumer; (optional) output parameters do not convey significant content and merely indicate
            the status of the operation&#8217;s invocation; the description focuses on the Data Consumer&#8217;s interface: depending on its implementation, the data is either retrieved via the Data Consumer&#8217;s request (PULL) or received on a subscription basis (PUSH).</td>
    </tr>
</table>


<h5><u>Parameters</u></h5>
<p>Parameters are named slots of data exchange via operations of the resource Interaction Interface. They are defined in terms of a Content type, Parameter type, and a Representation (serialization). The Content Type designates the semantics of the data passed through (not to be confused with the homonymic HTTP header). Parameters might refer to structures of the resource content, that are mediated by the Parameter, (e.g. a table column) in order to re-use their semantics definition.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3 21: Outline of the Parameter concept</i>
</p>

<p>Parameters share the Representation definition provided above. This is useful when mediating transient data which is not modeled as part of the resource content. The Parameter type provides hints to interface clients about the purpose and intended usage of the Parameter, and may e.g. support e.g. a query generation process. Table 6 provides a listing of currently envisaged, standard Parameter types.</p>
<p>Table 6: Resource Interaction Interface – overview of parameter types</p>

<table>
    <tr>
        <td><b>Parameter type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Resource</td>
        <td>Parameter used to mediate the resource Content, contrasted to parameters conveying auxiliary information.</td>
    </tr>
    <tr>
        <td>Identifier</td>
        <td>Parameter for passing identifiers of data elements as defined by a data collection. The resource identifier is unique and valid regardless of the actual extent, ordering, and view (filtering) of
            the Collection.</td>
    </tr>
    <tr>
        <td>Index</td>
        <td>Parameter conveying the transient, positional identifier of a resource in the context of an ordered Collection. The resource index is temporarily unique and valid only with respect to the actual
            extent, ordering, and view (filtering) of the Collection.</td>
    </tr>
    <tr>
        <td>Order</td>
        <td>Parameter indicating the order of data elements when retrieving or providing a collection of data elements; either implicit, following the natural order of the collection, or based on the &#8220;Sort
            key&#8221; parameter; valid values are formal equivalents of &#8220;none&#8221;, &#8220;ascending&#8221;, and &#8220;descending&#8221;.</td>
    </tr>
    <tr>
        <td>Sort key</td>
        <td>Parameter of the &#8220;Path&#8221; type indicating the key values underlying the order of data elements in a collection; to be applied to collections of &#8220;structured&#8221; data only.</td>
    </tr>
    <tr>
        <td>Offset</td>
        <td>Parameter indicating the absolute offset (number of data elements to skip) within an ordered data Collection.</td>
    </tr>
    <tr>
        <td>Limit</td>
        <td>Parameter indicating the number of data elements retrieved or provided at once within a paginated subset (page).</td>
    </tr>
    <tr>
        <td>Filter</td>
        <td>Parameter holding a filter expression used to retrieve a matching subset of a collection&#8217;s data elements.</td>
    </tr>
    <tr>
        <td>Path</td>
        <td>Extension of &#8220;Filter&#8221; parameter supporting hierarchical, nested data structures; examples are [XPath] and [JSONPath].</td>
    </tr>
    <tr>
        <td>Selector</td>
        <td>Parameter holding a selector expression used to retrieve a matching subset of a collection&#8217;s data elements.</td>
    </tr>
</table>

<h5><u>Service Layer</u></h5>
<p>The resource Interaction Interface can be turned into an executable service by binding it to a concrete communication protocol. A protocol binding provides a vocabulary to map the abstract operation signatures onto the concrete structures (e.g., HTTP headers or query parameters), configuration parameters (e.g., MQTT broker), and interaction patterns (e.g., WSDL [Message Exchange Patterns]) of a protocol. Each instance of a Protocol Binding defines a resource Endpoint, an addressable and operable point of resource exchange which communicates Representations of a resource in compliance with the definitions of underlying Resource Interaction Interface. The Information Model does not constrain Data Providers in the way they configure the individual protocol bindings but it should provide a guidance and example instances demonstrating a recommended practice.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.26: Outline of the resource endpoint concept</i>
</p>

<h5><u>Commodization View</u></h5>
<p>The Commodization view focuses on the "commodity" aspects of a resource, amongst others its price, licensing model, and usage restrictions. It optionally lists the available Quality of Service options (per resource endpoint). Once published, the static dimensions of the Product concept are augmented by dynamic statistics and community feedback (rating, comments, etc.) represented by the Feedback concept. The Product information allows a potential Data Consumer to estimate the expenses and commercial exploitability of a resource.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.27: Outline of the Product concept</i>
</p>

<h5><u>Pricing</u></h5>
<p>The Pricing strategies of data marketplaces identified in [ERCIS15] apply likewise to IDS resources. The Free strategy does not charge the usage of resources. The Freemium strategy exposes a limited parts (or capabilities) of the resource at no cost, while additional parts are charged Pay-per-Use, or based on a Flat Rate. The Pay-per-Use strategy relies on a particular metrics (volume, access count, download) to define a charged instance of usage, while the Flat Rate strategy charges usage per quantitative slot (time, volume, credit), optionally associated with a tier¬ed cost model according to the configuration of the retrieved resource.</p>

<h5><u>Regulations</u></h5>
<p>The regulatory aspects of the Commodization view are discussed in a separate section (see Section Facet 6:Regulations), because of their key role in implementing the data sovereignty of Data Owners and App Providers.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.28: Taxonomy of Product Pricing concepts</i>
</p>

<h5><u>Summary</u></h5>
<p>This section introduced the concept of an Industrial Data Space resource, a generalization of the core asset concepts, the Data Asset and Data App. The resource is an identifiable, valuable, digital (non-physical) commodity traded and exchanged between participants by means of infrastructure components of the Industrial Data Space. The specification of resource concept was given in terms of the Content, Communication, and Commodization views (3C-Principle). A refinement of the views by orthogonal layers lead to a complete description matrix as summarized in Figure 17.</p>


<h4>Facet 2: Data</h4>
<p>Data is the central asset of the Industrial Data Space. This section elaborates upon the concept of a Data Asset, an identifiable, non-physical entity that comprises data, or a service interface to data [NISTIR 7298]. The Data Asset concept is described only in the extent going beyond the description of the parent resource concept given above. Reference examples are presented to demonstrate the concept of a Data Asset. They demonstrate differences in the provision of static data versus dynamic data, different usage policies applied, different interaction patterns chosen, and different transfer protocols used.</p>

<h5><u>Examples</u></h5>
<p>The reference data stems from a hypothetical scenario of measuring traffic conditions at defined locations of the highway E37 for purposes of traffic control, predictive road maintenance, toll fee optimization and so on.</p>

<h5><u>Example DAT1: Off-line, free data download</u></h5>
<p>The example DAT1 showcases an easy, non-interactive access to free, historical data. Monthly reports on traffic statistics collected during a year are provided for download at a fixed web address (.../trafficreport/). File names (e.g., E37_up_2018_01.csv.zip) consist of the (underscore separated) identifier of the highway (e.g., "E37"), the direction of travel ("up" or "down", relative to highway mileage), year (e.g., "2018") and month (e.g., "01"), and (optionally) the file (csv) and compression extension (zip). HTTP content negotiation or default settings may supplement missing values for file type (Accept-header) and compression (Accept-Encoding-header). The reports comprise tabular data with a fixed number of labeled columns. Each row corresponds to an individual value tuple collected in a certain sampling area within a certain sampling period. The sampling area is identified by a readable name (String), a distance marker (double, km), and the geo-location (according to a predefined geo-spatial reference system). The remaining columns contain the measurement details, i.e. the time stamp of the sampling period (ISO 8601 period format, YYYY-MM-DDThh:mmPnYnMnDTnHnM), the average velocity (double, km/h), and the number of vehicles passing (integer). The data may be used free of charge, but the policy requires a credits citation.</p>

<h5><u>Example DAT2: On-line, commercial data query</u></h5>
<p>Example DAT2 introduces interactive features going beyond the retrieval of alternative representations of static content, allowing the Data Consumer to probe and accordingly operate services providing access to extended, growing datasets. In order to explore the dataset, the Data Consumer may request the value range of enumerable parameters (trafficreport/column/areaId), define valid filter conditions, and limit the report coverage to fit consumers' informational needs (trafficreport?filter=in(areaId,[id1,id2,id3]) in a fully automated manner. Elaborating upon the report structure of Example DAT1, the Data Consumer may learn about the available properties/columns (trafficreport/columns) and configure the report layout accordingly (trafficreport?column=areaId,timestamp,avgSpeed&orderBy=areaId,timestamp&order=asc). For some properties to be elicited, investments into dedicated sensory infrastructure may be required (e.g., weighbridge, vehicle type detection), making such values only commercially available (avgWeight, countVehicleTypeTruck). Pricing models may allow for discounts when combining payed properties. Depending on consumer’s request behavior, various payment models may be applied (pay-per-use, volume or time-based subscription, etc.). The usage policies of this sample prohibit resale of the commercial data parts.</p>

<h5><u>Example DAT3: Preprocessed, live data subscription</u></h5>
<p>While data exchange in the two previous samples was driven by the Data Consumer (pull-pattern), Example DAT3 showcases a data-driven delivery, for which the Data Consumer is provided with content on the basis of a previously made subscription (push-pattern). In the context of the traffic monitoring scenario, a Data Consumer subscribes to traffic parameters, which values match a particular complex event pattern deployed on Data Provider premises as part of the subscription (see Facet #3: Applications section for details on examples of such rules).</p>
<p>The following sections summarize aspects that are considered specific to Data Assets.</p>

<h5><u>Dynamicity</u></h5>
<p>Data can differ significantly in terms of dynamicity (i.e., the way data expands and can be updated). As far as frequency is concerned, data may change spontaneously (i.e., on an irregular basis) or regularly (e.g., at a certain sampling rate). A change may represent an extension, i.e., an insertion in the middle of, or an addition at the head of, an ordered collection, a partial or complete update (replacement), or deletion of a collection item. (Continuously) extended, live collections (sensor measurements, log entries, message queues, etc.) differ from static collections. The time variance of data needs to be explicitly modeled and considered when selecting the appropriate interaction and communication protocol.</p>

<h5><u>Context</u></h5>
<p>The context is defined by the temporal, spatial, and socio-economical (or world) coverage of the data, i.e. the range of time, space, or real world entities referred to by the data. Accurate and meaningful context modeling gives answers to questions like "when", "where", and "what", and is seen as a prerequisite for the assessment of data's relevance and business value with respect to the needs of Data Consumers. In the traffic scenario introduced above, the temporal context is the overall time period the data was collected in; its upper bound (end time) is undefined here because of the continuously extended live data). The spatial context of the examples may be defined by the geographical extent (union of bounding boxes) enclosing the sampling area. The world context may comprise the enumeration of the highways as a real-world objects of interest. An overly broad and excessive context description might impede the discoverability and value assessment of the Data Asset.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.30: Taxonomy of the Data Asset Context</i>
</p>

<h5><u>Topic</u></h5>
<p>The topic of a Data Assets emphasizes the essential statement of the data, its purpose, or interpretation. It might express the relation of data to the world context. Topics appropriate in a given traffic scenario are, for example "monitoring", "statistics", etc.</p>

<h4>Facet 3: Applications</h4>
<p>The Application facet focuses on the description of reusable software and auxiliary artifacts delivering a data-specific functionality. Data Apps are self-contained and self-descriptive software packages (e.g. Linux Containers) extending the functionality of the generic Connector with custom capabilities. In addition, there are Data App Plug-ins and Data App Assets. A Data App Plug-in is an add-on of a Data App, adding new capabilities to it. The extension management process for selection, installation, and maintenance of such plugins has to be implemented by the respective Data App in accordance with the security policies of the Connector. A Data App Asset is a machine-interpretable Data Asset, such as a script file, algorithm, rule set, or another type of code, which execution relies on a particular runtime environment.</p>

<h5><u>Examples</u></h5>
<p>The following reference examples demonstrate the provision, extension, and configuration of application logic in context of the traffic scenario.</p>

<h5><u>Example DAP1: Data App for image anonymization</u></h5>
<p>The photographs taken by the surveillance camera have to be anonymized before being forwarded to a Data Consumer. This sample accepts images of standard traffic scenarios in various file formats (e.g. PNG, JPG) recorded in compliance with the international norm [EN 50132-7]. It is trained to locate particular personal information (e.g., the license plate of a car) and to apply image processing techniques to irreversibly obfuscate this information.</p>

<h5><u>Example DAP2: Data App Plugin for advanced image processing</u></h5>
<p>There may be scenarios that impose advanced privacy requirements and require a dedicated plug-in to augment the aforementioned sample with a capability of advanced image processing (e.g., face anonymization).</p>

<h5><u>Example DAP3: Data App Asset as interpreted CEP rule (DAP3)</u></h5>
<p>The Data Consumer in the traffic scenario might define complex event processing (CEP) rules as part of a data subscription in order to shift the task of processing and monitoring live data at the edge of the network (edge computing). One such rule may request a notification sent every time the average speed in a critical area dropped below 10 km/h within the last 5 minutes (risk of congestion). Likewise, a notification is sent every time a truck weighing more than 20t heads towards a bridge that has only limited load carrying capacity (limited access). The content of the notification message, the communication protocol (MQTT), the quality of the service parameters (at-least-once delivery), and other details are defined by the rule as part of the subscription.</p>

<h5><u>Dimensions</u></h5>
<p>In course of their life-cycle Data App may be considered according to various dimensions, as illustrated by Figure 19.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.31: Dimensions of Data Apps</i>
</p>
<p>The Resource dimension, shared by Data Assets and Data Apps, specifies their quality as a tradable digital commodity according to the 3C-Principle. The Functionality dimension expresses the functional potential, i.e. data handling capabilities, of a Data App published via the App Store component. The Deployment dimension deals with the runtime aspects of a concrete application deployment (security updates, quality of service and usage control enforcement etc.).</p>

<h5><u>Resource</u></h5>
<p>The following sections focus on the Resource dimension of the Data Apps. The views and layers of the 3C-Principle are instantiated according to characteristics of Data Apps.</p>

<h5><u>Content View</u></h5>
<p>The Content View considers the static, structural aspects of the Data App Resource. Its general Kind is expressed by a reference to a shared taxonomy of applications Categories, while a detailed modeling of the functionality is delegated to the Functionality dimension. The Representation Layer defines the distributions available as a combination of available software file formats and general properties of the target system (hardware architecture, operating system). Optionally, the Artifact Layer may elaborate about the structure, dependencies, configuration and requirements of a particular application build.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.32: Content view of the Data App resource</i>
</p>
<p>The Structure concept discloses the internal software components the Data Apps uses or is based on. It allows to estimate their technical maturity, potential technical and security risks, e.g. once defects or security vulnerabilities of those components were reported. The Dependencies concept deals with the reliance on external software artifacts. The Environment concept encompasses the requirements on the execution context of the Data App, among others the runtime environment (J2EE, Linux-Container runtime), its configuration, and resources made available to the application (storage volume, network ports, memory, CPU). Finally, the Configuration concept describes the configuration options and default settings etc. The Signature concept covers the verifiable identity, integrity and formal IDS certification of the Artifact.</p>

<h5><u>Communication View</u></h5>
<p>The Communication view deals with the physical distribution of the Data App resource. Depending on the distribution strategy, a signed Data App might be provided in a decentralized manner by the Application Provider, similarly to a Data Asset, or retrieved from a central App Store repository. In the former case, the Application Provider has to define a resource Endpoint within a local Connector and publish it to the App Store Registry. Its resource Interaction Interface should enable the prospective Application user to select, customize and download an appropriate Data App resource. In the latter, default case, these tasks are handled by a generic resource Endpoint exposed by the App Store Repository.</p>

<h5><u>Commodization View</u></h5>
<p>In addition to the general considerations of the Resource Commodization View, specific aspects apply for Data Apps. An obvious example are the various deployment options, as listed in Table 7. Both on-premises deployment options impose additional agreements with regard to maintenance, upgrades, and usage policy enforcement.</p>
<p>Table 7: Deployment options of Data Apps</p>

<table>
    <tr>
        <td><b>Deployment option</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>On-premises installation</td>
        <td>A Service Provider deploys the Data App inside of an on-premises IDS Connector on behalf of the Data Provider. This is assumed to be the default case.</td>
    </tr>
    <tr>
        <td>On-premises injection</td>
        <td>A Service Provider deploys the Data App inside of an on-premises IDS Connector on behalf of the Data Consumer (asking for customized data preprocessing, according to contract specifications;
            e.g., edge computing).</td>
    </tr>
    <tr>
        <td>Remote integration</td>
        <td>A Service Provider integrates a remote Data App service on behalf of the Data Provider. In this scenario, the Data App is hosted by different participants and used remotely.</td>
    </tr>
</table>

<h5><u>Functionality</u></h5>
<p>The Functionality dimension expresses the capabilities of a Data App to handle a type of data in a particular way. The Content view details out the Kind and syntactic Representation of the data in question. At the definition time there are no concrete data instances to be handled, therefore the Artifact layer of the Content view is omitted. Please refer to Section Content View for details. The Communication view defines a custom Data Interface in terms of Operations exposed by the Data App. Figure 21 summarizes the main aspects of the Functionality dimension.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.33: Description matrix of the Data App Functionality dimension</i>
</p>

<h5><u>Communication View</u></h5>
<p>The Communication view considers in this context the abstract Data Interface (Interface Layer) of a Data App and its materialization as a Data Service (Service Layer).</p>
<p>The Data Interface models the effective functionality of a Data App. It encapsulates a range of Operations upon data passed via the Parameters of the Operation. The semantic type of an Operation indicates the processing of and effect on input data in an interoperable way. The set of available Operation types includes the subset of Resource Interaction Interface Operation types and is deliberately not restricted. Data App Developers are free to specify custom Operation types in accordance to the Information Model governance rules. Depending on the data flow and interactions supported by the individual Operations, a Data App may act as a Data Providing App, Data Processing App or a Data Consuming App. These concepts are not disjoint, a single Data App may simultaneously implement any combination of these roles.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.34: Data App taxonomy</i>
</p>
<p>A Data Providing App exposes data by means of at least one Provide data Operation, as illustrated by Figure 23. Equally a Data Consuming App exposes at least one Consume data Operation in order to receive (and store) data. Please refer to Table 5 for a definition of those Operation types.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.35: Outline of the Data Providing App concept</i>
</p>
<p>Data Processing Apps expose custom functionality via at least one Process Data Operation. The range of such Operation types is rather infinite, the Table 8 provides some examples of possible subclasses.</p>
<p>Table 8: Examples of Process data Operation types</p>

<table>
    <tr>
        <td><b>Process data Operation type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Annonymize Data</td>
        <td>Type of Operation used in reference example DAP1. The input and output are image files of traffic situations. Processing removes personally identifiable information (license plate).</td>
    </tr>
    <tr>
        <td>Aggregate Data</td>
        <td>Type of Operation used in reference example DAP3. The Input and output are event
            messages of a predefined type. The evaluation of sensor measurements by a complex event processing rule results
            in the generation of new, higher-order events.</td>
    </tr>
    <tr>
        <td>Transform Data</td>
        <td>Type of Operation used to transform a structured input into a semantically equivalent, but syntactically incompatible Representation.</td>
    </tr>
</table>

<p>At the Service layer Data Apps may require bindings to further, e.g. native protocols (IPC socket) in addition to "remote", web-based protocols involved in exchange of resources. The corresponding requirements and examples are being collected and will be included in the next document iteration. The Service description in context of the Functionality dimension is inevitably incomplete, the Data Service model remains a template with no references to a real Deployment.</p>

<h5><u>Deployment</u></h5>
<p>The Deployment dimension deals with concrete installations of Data Apps. A previously incomplete Data Service template becomes instantiated into a physically accessible Service model (endpoint) based on parameters of the host environment (IP address, port etc.). Data Providing and Data Consuming Apps may easily be turned into resource Endpoints by complementing their description in accordance with the 3C-Principle (e.g. by addition of the missing Product layer). The tasks to be supported by an Information Model of a Data App Deployment are, among others, the tracking of administration provenance (modifications applied to the application), logging of execution parameters (downtimes, usage of computational resources, service availability etc.) and the support of maintenance life-cycle (security updates etc.).</p>

<h5><u>Summary</u></h5>
<p>This section elaborated upon the concept of a Data App, a re-usable software and auxiliary artifacts delivering a data-centric functionality. Data Apps were analysed along three dimensions. The resource dimension considers Data Apps as a tradable digital commodity according to the 3C-Principle. The Functionality dimension expresses its data handling capabilities, whereas the Deployment dimension deals with the runtime aspects of a concrete application deployment. Depending on the data flow and interactions supported Data App were categorized as a Data Providing App, Data Processing App, and Data Consuming App.</p>


<h4>Facet 4: Infrastructure</h4>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.36: Taxonomy of infrastructure components</i>
</p>
<p>Figure 24 outlines a taxonomy of the main Infrastructure components of the Industrial Data Space. The Connector is its core building block, a communication server providing and consuming data by means of Data Apps via a number of resource endpoints. The Broker component is a meta-data registry of Data Asset offerings, whereas the App Store is a registry of Data App offerings and a secure registry for their distribution. The Vocabulary Hub serves the maintenance of shared vocabularies and related (schema) documents. The Identity Provider manages and validates the digital identity of Industrial Data Space Participants. The Clearing House provides clearing and settlement services B2B interactions within the Industrial Data Space.</p>

<h5><u>Connector</u></h5>
<p>Being the dedicated point of data exchange and usage policy enforcement, the Connector is the central component of the infrastructure. It constitutes the basis for the implementation of other, more specialized components, such as the Broker. Each Connector may expose an arbitrary number of resource endpoints, offerings of digital commodities that are optionally advertised by publication at the meta-data registries, the Broker, or App Store respectively. The Deployment Context of a Connector comprises the geo-location information (e.g., country of deployment or applicability of national law), deployment type (on-premises vs. cloud). Furthermore, the responsible Participant operating the Connector (Service Provider) is referenced.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.37: Outline of the Connector concept</i>
</p>
<p>A Connector may specify the supported Security Profile in order to indicate a level of technical trustworthiness. The Security Profile is composed of several security options, which are outlined in Figure 26, among others the capability of a remote integrity verification, applications isolation level etc.  Predefined configurations of Security Profiles should be supplied in order to identify common security levels of Connectors (e.g. Base Connector, Trusted Connector etc.).</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.38: Outline of the Security Profile concept</i>
</p>
<p>The capabilities of enforcing data usage control by the Connector are modeled as part of the Security profile. These cover information whether and how certain usage control policies (e.g., mandatory deletion of data after a certain period of time) are automatically enforced by the Connector (i.e., on the technical level) or supported by governance processes during the data consumption process (i.e., on the organizational level).</p>


<h4>Facet 5: Participants</h4>
<p>A participant is a legal or natural person assuming a role (or more than one role) in the Industrial Data Space. For certain, critical roles to assume, participants must undergo a certification. Certification of participants is considered a measure to establish trust across the Industrial Data Space.</p>

<h5><u>Examples</u></h5>
<p>Instances of participants involved in the traffic scenario are outlined below.</p>

<h5><u>Example PAT1: Multi-national logistics company</u></h5>
<p>MAIER Logistics is a multinational logistics company with hundreds of trucks driving throughout Europe. The company is interested in live traffic monitoring data, as it wants to provide its drivers with up-to-the-minute traffic information to allow for efficient routing and timely issuing of hazard warnings. In this scenario, MAIER Logistics is an organization that runs several sites, such as MAIER Deutschland, Musterstraße 5, Köln, Deutschland, or MAIER UK, Example Road 5, Liverpool, United Kingdom. The organization complies with the ISIC classification rev. 4 and has ISIC code 4923 (freight transport via road). For this scenario, the company’s distribution departments are relevant, being the organizations which control and monitor outbound distribution via trucks. The distribution departments are part of the MAIER Logistics Organization. Each distribution department has a specific site. The German Distribution department is located at MAIER Logistics Distribution Cologne, Musterallee 323, Köln, Deutschland. MAIER Logistics Distribution Cologne assumes the role of a Data Consumer in data Example DAT3. It has a valid certificate and a unique identity. As a Data Consumer, it receives notifications with hazard warnings and congestion information. The information received is processed by a custom software of the department, which sends the information to the trucks using geo-location information.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.39: Outline of the Participant concept</i>
</p>

<h5><u>Organization and Person</u></h5>
<p>A Participant can be an organization (or organizational unit) or an individual. If the participant is an organization, it may consist of sub-organizations, departments, or other organizational structures. Corporations may indicate an organizational structure by linking to subsidiary companies or organizational units acting as related, but more or less independent participants. This approach allows sharing authorization certificates along a trust chain and enforcing company-wide policies. If the participant is an individual, he or she may assume a specific role in the corresponding organization.</p>

<h5><u>Business Classification</u></h5>
<p>Participants may indicate the type of business and the domain in which they operate by making references to established business classifications, i.e., business catalogs or registries. The classification can be used, for example, to search for data assets according to business category. For formal representation of business classifications, e.g. NAICS identifiers can be used. These are part of the extended core of the Industrial Data Space Information Model. It will therefore be possible to support additional classification schemes (such as D&B D-U-N-S® Number, ISIC, or UNSPSC) in future revisions of the extended core model.</p>

<h5><u>Site</u></h5>
<p>Each Participant can be assigned to one or more unambiguously defined Sites. Site information comprises the name and address of the site as well as geo-location information. It is particularly important in cases in which specific rules (e.g., national law) apply, affecting, for example, the data usage control policy.</p>

<h5><u>Identity</u></h5>
<p>By default, and in accordance with linked-data principles, a participant can unambiguously be identified by a dereferencable HTTPS URL, which references to a live meta-data document describing the participant. This identity is confirmed by a (X509) certificate.</p>


<h4>Facet 6: Regulations</h4>
<p>This section refers to contracts and policies governing the interactions of participants and how they use data assets.</p>

<h5><u>Usage Contract</u></h5>
<p>A pivotal part of the Product concept introduced by the Commodization view of resources in Section Commodization View is the formal expression of Usage Contracts pertaining to the Product. The Usage Contract defines a validity Period and formal Rules agreed upon by Participants involved in the provision, or subsequent usage of the Product.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.40: Outline of the Usage Contract concept</i>
</p>
<p>The Rules specify Actions that an involved Party (Participant) is obliged, permitted or prohibited to perform with respect to an Asset (resource or a collection of resources). Formal Constraints state the applicability of Rules and refine the interpretation of Actions. Given the reference data example DAT1, a Permission allowing for an unrestricted usage of the data holds when the Data Consumer met her Obligation to cite the data source. The Reference data example DAT2 prohibits the resale of commercial data segments via a Prohibition on Data Consumer. With respect do data example DAT3 a Duty may express the Obligation on Data Provider to maintain a particular Quality of Service (QoS) level, i.e. publish the live sensor data at a particular rate and warrant a reliable delivery (QoS level "at least once").</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.41: Outline of the Rule concept</i>
</p>
<p>Usage Contracts formalize the expectations on behavior of involved Participants in a declarative, technology-agnostic way. The perpetual control and enforcement of such specification level policies may involve the inception of governance processes or, when appropriate the deployment of a technological solution. Data Usage Control Frameworks like [IND²UCE] define implementation-level policy languages in terms of technology-dependent events and actions, i.e. access to or modification of single files. Appropriate Policy Mappings should be specified to cope with the obvious conceptual gap between both policy levels and to enable a reliable and affordable technological enforcement of (parts of) Usage Contracts. Usage Contracts therefore should indicate an enforcement strategy and, in case of a technological enforcement, the Policy Mappings to be supported by the target Connector. As mentioned in Section Connector, a Connector should disclose its Usage Control capabilities as part of its Security Profile.</p>

<h5><u>Subscription</u></h5>
<p>The Subscription concept expresses an Obligation to deliver data at a particular Quality of Service mandated by the Usage Contract from an active Data Source to a number of subscribed Data Sink targets within the given Period.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.42: Outline of the Subscription concept</i>
</p>


<h4>Facet 7: Interactions</h4>
<p>The Interactions facet deals with concepts underlying business interactions among the IDS Participant, i.e. the interchange and consumption of Resources according to defined Regulations. The internal maintenance and operation processes of the IDS Infrastructure are considered afterwards. Both facet are subject to an ongoing change and are presented in a limited extent.</p>

<h5><u>Data Transfer</u></h5>
<p>Each Resource interchange in the Industrial Data Space is modeled as an instance of the Data Transfer concept. It specifies a minimalistic meta-data model supporting security, traceability and usage control purposes. The Data Transfer refers to the originating and target Resource Endpoints, the time-stamp and the Payload (Resource) being distributed. The message is optionally signed and contains an authentication token (Trusted Connector). The Data Transfer carries a reference to the underlying Usage Contract, a source of formerly aggreed usage policies, optionally augmented by a dynamic instance of a Usage Policy.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.43: Outline of the Data Transfer concept</i>
</p>


<h4>Facet 8: Maintenance</h4>
<p>The Maintenance facet deals with the concepts describing the internal processes of maintenance and operation of the IDS Infrastructure, including the maintenance and dissemination of shared informational Resources, e.g. Ontologies.</p>

<h5><u>Life-cycle tracking</u></h5>
<p>Infrastructure components of the Industrial Data Space are subjects to administrative operations, i.e. a life-cycle management defined by a set of States. The transition among these states are triggered by standardized Activities performed by administrative Agents. A record of life-cycle events should be maintained, e.g. to analyze and prevent failure conditions. Likewise the meta-data descriptions of Resources and Participants evolve over the time demanding for a life-cycle management and versioning. Such, e.g. historical versions of contracts have to be maintained alongside with recent revision or the representation of a Participant, created at some point may become temporarily suspended or permanently blocked. The concept of an Entity with Lifecycle was introduced to represent entities that are subject to evolution which needs to be tracked.</p>
<br>
<p>
    <!-- Bildplatzhalter -->
    <i>Figure 3.44: Outline of the Entity with Lifecycle</i>
</p>


<h3>3.3 Vocabularies</h3>
<p>Combining data from various sources in different formats and modeling views requires both syntactic and semantic integration efforts. Whereas a syntactic integration can be established by relying on common data formats, like XML or JSON, the semantic variety also needs a shared and formalized understanding on the meaning of the used terminology. In particular, searching and selecting data sources, exchanging datasets and invoking and accessing software services requires explicit information on the meaning of concepts.</p>
<p>Controlled vocabularies are the most basic form of shared concepts. While the meaning and spelling of terms is determined, no further information on the inherent structure is modeled. As such, controlled vocabularies form a light-weight approach with low entry barriers for data integration among partners and systems where a basic data exchange with restricted background information is sufficient.</p>
<p>Taxonomies extend the controlled vocabularies by adding hierarchichal relations to the concepts and allow the modeling of catgorise and classifications. In order to express even further statements regarding relations and dependencies but also to allow automatic infering of new data and knowledge, ontologies provide a formal and machine-understandable form of information modeling. In recent years, RDF has become the de facto standard for expressing ontolgies by strictly relying on URIs as identificators of concepts. In that sense, the referent of a concept is not its natural language representation, as in general applied for controlled vocabularies, but a URI modeled as nodes in a so called knowledge graph.</p>
<p>The IDS expresses its Information Model as an RDF ontology in order to achieve unambigous identifiers and formalized definitions of its concepts and relations. In order to simplify the integration of the IDS ontology, descriptions directly conencted to the respective concepts and links to widely-known concepts of so called upper-level ontologies provide further explanations. As data exchange between different parties is a the core of the IDS, only a fundamental core vocabulary for data descriptions and exchange invokations is requried for all IDS participants. Domain-specific vocabularies may be used wherever necessary to extend the core concepts and to supply more information on provided or requested data.</p>
<p>The Industrial Ontology Foundary (IOF) provides a common reference framework for manufacturing-related vocabularies. The thereby defined terms provide a higher usability in comparision to other vocabulary providers as the IOF vocabulary represents the condensed view of a broad ratio of the manufactoring industry. Additional domain specific vocabularies describe certain industry needs or requirements. Commonly known examples are the Semantic Sensor Network (SSN) or the Sensor, Observation, Sample, and Actuator (SOSA) ontology. Widely used tools for creating and maintaining ontologies are the OWL IDE Protégé, the web-based WebVOWL and VoCol, a reference implementation of the IDS Vocabulary Provider. In addition, other common vocabularies are standardized eCl@ss for product and service related concepts and dictionaries published by RosettaNet.</p>

<h3>3.4 App Interfaces</h3>
<p>In the same ways IDS connectors need to supply information on their identity, functionality, and interaction capabilities, IDS Data Apps are equipped with meta information according to the IDS Information Model. These description files provide, among others, details on their intended usage and purpose, their security level but also the applied licensing model. In addition, provider may further describe the Data Apps with vocabularies outside of the IDS core ontology. For instance, domain specific explanations may require further terms and concepts.</p>
<p>The description of Data Apps eases the discovery and selection at an IDS App Store. Consequently, the metadata must contain all necessary information to determine the offered value and applicability of the respective apps. Furthermore, the metadata is a fundamental building block for the deployment and composition of several Data Apps at a local IDS Connector. Therefore, all operations have to be defined in terms of input and output parameters, bound protocols and endpoints. Preconditions and postconditions need to be made explicit and effects on the environement must be outlined.</p>